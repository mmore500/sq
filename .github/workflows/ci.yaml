name: HPCC Job Monitor

on:
  push:
    branches:
      - master
  pull_request:
    branches:
      - master
  schedule:
    - cron: "*/5 * * * *"  # every 5 minutes
  workflow_dispatch:

permissions:
  contents: read
  pages: write
  id-token: write

concurrency:
  group: "pages"
  cancel-in-progress: true

jobs:
  actionlint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Check workflow files
        uses: docker://rhysd/actionlint:latest
        with:
          args: -color
  fetch-jobs:
    if: github.event_name != 'pull_request' || github.event.pull_request.head.repo.full_name == github.repository
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install sshpass
        run: sudo apt-get update && sudo apt-get install -y sshpass

      - name: Run job script on HPCC
        id: hpcc
        run: |
          set -e
          sshpass -p "${{ secrets.PASSWORD }}" ssh -o StrictHostKeyChecking=no "${{ secrets.USER }}@hpcc.msu.edu" 'bash -s' <<'EOF' | tee job_status.txt
          job_list=$(squeue --noheader -u "$USER" -o "%i|%j|%t|%M|%R")

          # --- Counters ---
          running_count=0
          pending_count=0
          held_count=0
          completing_count=0
          total_jobs_count=-1  # fix off-by-one
          declare -A category_counts
          declare -A category_num_jobs
          declare -A category_state_counts
          total_num_jobs=0

          # --- First pass: compute summaries ---
          while IFS='|' read -r job_id job_name state time nodelist; do
            total_jobs_count=$((total_jobs_count + 1))

            # Detect Held by user
            if [[ "$nodelist" == *"(JobHeldUser)"* ]]; then
              held_count=$((held_count + 1))
              category_label="Held"
            else
              case "$state" in
                R)  running_count=$((running_count + 1)); category_label="Running" ;;
                PD) pending_count=$((pending_count + 1)); category_label="Pending" ;;
                CG) completing_count=$((completing_count + 1)); category_label="Completing" ;;
                *)  category_label="$state" ;;
              esac
            fi

            # Parse category: ensure first a= is taken
            if [[ "$job_name" == *"a="* ]]; then
              job_type=$(printf '%s' "$job_name" | sed -n 's/.*a=\([^+[:space:]]*\).*$/\1/p')
              if [[ -n "$job_type" ]]; then
                category_counts["$job_type"]=$(( ${category_counts["$job_type"]:-0} + 1 ))
                category_state_counts["$job_type|$category_label"]=$(( ${category_state_counts["$job_type|$category_label"]:-0} + 1 ))

                # Parse num_jobs if present
                num_jobs=$(printf '%s' "$job_name" | sed -n 's/.*num_jobs=\([0-9][0-9]*\).*/\1/p')
                if [[ -n "$num_jobs" ]]; then
                  category_num_jobs["$job_type"]=$(( ${category_num_jobs["$job_type"]:-0} + num_jobs ))
                  total_num_jobs=$(( total_num_jobs + num_jobs ))
                fi
              fi
            fi
          done <<< "$job_list"

          # --- Print summary at the top ---
          echo "===== Job Summary ====="
          printf "%-22s %d\n" "Total jobs:" "$total_jobs_count"
          printf "%-22s %d\n" "Running jobs:" "$running_count"
          printf "%-22s %d\n" "Pending jobs:" "$pending_count"
          printf "%-22s %d\n" "Held jobs:" "$held_count"
          printf "%-22s %d\n" "Completing jobs:" "$completing_count"
          echo ""

          echo "===== Jobs by category (count of jobs) ====="
          for jt in $(printf '%s\n' "${!category_counts[@]}" | sort); do
            printf "%-30s %d\n" "$jt:" "${category_counts[$jt]}"
          done
          echo ""

          echo "===== num_jobs by category ====="
          for jt in $(printf '%s\n' "${!category_counts[@]}" | sort); do
            printf "%-30s %d\n" "$jt:" "${category_num_jobs[$jt]:-0}"
          done
          printf "%-30s %d\n" "Total num_jobs:" "$total_num_jobs"
          echo ""

          echo "===== Jobs by category and state ====="
          for jt in $(printf '%s\n' "${!category_counts[@]}" | sort); do
            printf "%-20s" "$jt:"
            for label in Running Pending Held Completing; do
              count=${category_state_counts["$jt|$label"]}
              if [[ -n "$count" ]]; then
                printf "  %s=%d" "$label" "$count"
              fi
            done
            echo ""
          done
          echo ""

          echo "===== Quota Usage ====="
          /usr/local/hpcc/bin/quota-scripts/userquota.py | sed 's/\x1b\[[0-9;]*m//g' || echo "quota failed"
          echo ""
          echo "===== Detailed Job Table ====="

          # --- Print detailed job table ---
          printf "\n%-10s %-120s %-10s %-10s %-30s\n" "JobID" "JobName" "State" "Time" "Reason/Nodelist"
          while IFS='|' read -r job_id job_name state time nodelist; do
            printf "%-10s %-120s %-10s %-10s %-30s\n" "$job_id" "$job_name" "$state" "$time" "$nodelist"
          done <<< "$job_list"
          EOF

      - name: Parse quota usage and notify via Pushover
        env:
          PUSHOVER_TOKEN: ${{ secrets.PUSHOVER_APP_TOKEN }}
          PUSHOVER_USER: ${{ secrets.PUSHOVER_USER_KEY }}
        run: |
          set -euo pipefail
          python3 <<-'PY'
          	import re
          	rows = []
          	with open("job_status.txt", encoding="utf-8") as fh:
          	    in_quota = False
          	    for line in fh:
          	        if line.startswith("===== Quota Usage"):
          	            in_quota = True
          	            continue
          	        if not in_quota:
          	            continue
          	        if line.startswith("===== ") and "Detailed Job Table" in line:
          	            break
          	        if not line.startswith("|"):
          	            continue
          	        parts = [part.strip() for part in line.strip().split("|")[1:-1]]
          	        if len(parts) < 9:
          	            continue
          	        directory = parts[0]
          	
          	        def extract_pct(value: str) -> float:
          	            match = re.search(r"([0-9]+(\.[0-9]+)?)%", value)
          	            return float(match.group(1)) if match else 0.0
          	
          	        space_pct = extract_pct(parts[4])
          	        files_pct = extract_pct(parts[8])
          	        print(f"parsed {space_pct=} {files_pct=}")
          	        if directory and (space_pct >= 70 or files_pct >= 70):
          	            rows.append((directory, space_pct, files_pct))
          	
          	if rows:
          	    lines = ["Quota usage warning:"]
          	    for directory, space_pct, files_pct in rows:
          	        lines.append(f"{directory}: space {space_pct:.1f}% | files {files_pct:.1f}%")
          	    with open("quota_alert.txt", "w") as f:
                    print("\n".join(lines), file=f)
          	PY
          if [ -s quota_alert.txt ]; then
            message=$(cat quota_alert.txt)
            echo "Quota threshold exceeded. Sending Pushover notification."
            echo "${message}"
            curl -fsS \
              --form-string "token=${PUSHOVER_TOKEN}" \
              --form-string "user=${PUSHOVER_USER}" \
              --form-string "title=HPCC quota usage warning" \
              --form-string "message=${message}" \
              https://api.pushover.net/1/messages.json
          else
            echo "No quota metrics exceeded the threshold."
          fi

      - name: Generate webpage
        run: |
          set -euo pipefail
          mkdir -p public
          runtime_stats=$(python3 -c 'from textwrap import dedent; exec(dedent("""
            import statistics
            from pathlib import Path


            def parse_time_to_seconds(time_str: str) -> int:
                time_str = time_str.strip()
                if not time_str or time_str in {"-", "N/A"}:
                    return 0

                days = 0
                rest = time_str
                if "-" in rest:
                    day_part, maybe_rest = rest.split("-", 1)
                    if day_part.isdigit():
                        days = int(day_part)
                        rest = maybe_rest

                parts = rest.split(":")
                try:
                    parts = [int(part) for part in parts]
                except ValueError:
                    return 0

                hours = minutes = seconds = 0
                if len(parts) == 3:
                    hours, minutes, seconds = parts
                elif len(parts) == 2:
                    minutes, seconds = parts
                elif len(parts) == 1:
                    seconds = parts[0]
                else:
                    return 0

                return days * 86400 + hours * 3600 + minutes * 60 + seconds


            def format_seconds(value: float) -> str:
                total_seconds = int(round(value))
                days, remainder = divmod(total_seconds, 86400)
                hours, remainder = divmod(remainder, 3600)
                minutes, seconds = divmod(remainder, 60)

                if days > 0:
                    return f"{days}-{hours:02d}:{minutes:02d}:{seconds:02d}"
                if hours > 0:
                    return f"{hours}:{minutes:02d}:{seconds:02d}"
                return f"{minutes}:{seconds:02d}"


            lines = Path("job_status.txt").read_text(encoding="utf-8").splitlines()
            times = []

            for idx, line in enumerate(lines):
                if line.startswith("===== Detailed Job Table"):
                    pointer = idx + 1
                    while pointer < len(lines) and not lines[pointer].strip():
                        pointer += 1
                    if pointer < len(lines):
                        pointer += 1
                    for row in lines[pointer:]:
                        if row.startswith("====="):
                            break
                        if not row.strip():
                            continue
                        segment = row[143:] if len(row) > 143 else ""
                        time_field = segment.split(None, 1)[0] if segment.strip() else ""
                        if not time_field:
                            continue
                        seconds = parse_time_to_seconds(time_field)
                        if seconds > 0:
                            times.append(seconds)
                    break

            if times:
                times.sort()
                max_val = times[-1]
                mean_val = sum(times) / len(times)
                median_val = statistics.median(times)
                print("|".join([
                    format_seconds(max_val),
                    format_seconds(mean_val),
                    format_seconds(median_val),
                ]))
            """))')
          echo "runtime_stats $runtime_stats"
          runtime_max=""
          runtime_mean=""
          runtime_median=""
          if [ -n "$runtime_stats" ]; then
            IFS='|' read -r runtime_max runtime_mean runtime_median <<< "$runtime_stats"
            {
              echo "===== Runtime elapsed (nonzero) ====="
              printf "%-22s %s\n" "Max runtime elapsed:" "$runtime_max"
              printf "%-22s %s\n" "Mean runtime elapsed:" "$runtime_mean"
              printf "%-22s %s\n" "Median runtime elapsed:" "$runtime_median"
              echo ""
              cat job_status.txt
            } > job_status_with_stats.txt
            mv job_status_with_stats.txt job_status.txt
          fi

          epoch_ms=$(date +%s000)
          {
            echo "<!DOCTYPE html>"
            echo "<html><head><meta http-equiv=\"refresh\" content=\"60\">"
            echo "<title>HPCC Job Monitor</title></head><body>"
            echo "<h3 id=\"last-updated\">Updated: $(TZ=America/New_York date) (<span id='since'></span>)</h3>"
            echo '<a href="https://github.com/mmore500/sq">source</a>'
            echo '<a href="https://github.com/mmore500/sq/actions/workflows/ci.yaml">action</a>'
            echo "<script>"
            echo "  const lastUpdate = new Date($epoch_ms);"
            echo "  function updateSince() {"
            echo "    const now = new Date();"
            echo "    const diffMs = now - lastUpdate;"
            echo "    const mins = Math.floor(diffMs / 60000);"
            echo "    const text = mins === 1 ? '1 minute ago' : mins + ' minutes ago';"
            echo "    document.getElementById('since').textContent = text;"
            echo "  }"
            echo "  updateSince();"
            echo "  setInterval(updateSince, 60000);"
            echo "</script>"
            echo "<pre>"
            cat job_status.txt
            echo "</pre>"
            echo "</body></html>"
          } > public/index.html

      - name: Create numbered page copies
        run: |
          for i in {0..999}; do
            cp public/index.html "public/${i}.html"
            cp public/index.html "public/$(printf '%03d' "$i").html"
          done

      - name: Upload artifact for GitHub Pages
        uses: actions/upload-pages-artifact@v3
        with:
          path: ./public

  deploy:
    if: github.event_name != 'pull_request'
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    needs: fetch-jobs
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
